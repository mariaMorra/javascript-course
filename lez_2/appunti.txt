/*
conceptual aside 1: syntax parsers, execution contexts and lexical environments
-syntax parser= program that read code, determines what it does and checks grammar (compiler/intepretrer)
    they can do "extra stuff"
-lexical environments: exists in programming languages that are such that WHERE you write a part is important
    ->exemple: var or fun can be seen only after they have been reached and read
-exexcution contexts: wrapper to help manage the code that is running 
    base in js is: GLOBAL execution context that creates a global object and a special variable: "this" ->console wt empty js on wich "this" is written will return an object
    in a browser the object "window" is also created (and assigned to "this")
*/

/*
conceptual aside 2: name/value pairs and objects
->name value pair: name which maps to a unique value (which can be a name/value pair as well)
->an object: in JS can be defined as a collection of name/value pairs
*/

/* 
execution context is created in 2 phases:
1)creation phase: creates global object and variable "this" and outer enviroment,
    HOISTING: your code is read 1Â° time and sets up  MEMORY SPACE FOR BOTH VARIABLES AND FUNCTIONS
        ->VARIABLE EXIST BUT HAVE NO VALUE YET
        ->FUNCTIONS ARE set up completedly
2)execution phase: gives values to variables and ecc does the rest of it basically

NB do NOT BASE YOUR CODE ON HOISTING
-> MANTIENI NORMALE FORMA (PRIMA LA CREAZIONE DELLE FUNZ ECC POI L'ESECUZIONE) 
*/

/*
conceptual aside 3: undefined
all variables are initially hoisted wt value "undefined"
->special value and keyword for js for vars that are created but not given any other value
NB: NEVER ESPLICITLY SET A VAR TO UNDEFINED YOURSELF!!!
it's dangerous for debugging code -> if u see it u know u did NOT set the var

{[(nb dont use var use let? idr why tho)]}

*/
/*
second phase of execution context creation: execution phase
->globlal obj, this, outer environment created
->now it runs code line by line 
    interpeting, converting, compiling, executing it
*/

/*
Single threaded: 1 command at a time
sinchronous: 1 at a time, in order
*/

/*
invocation=calling=running a function
function invocation and execution stack
function invocation->ask to execute function by writing in code: name(pars)
(compiler interprets the code)
each call of a function adds a new execution context is created and placed on top of the stack
->the top one is the executing one
->and function execution has the same passages (create & hoist functions and vars, execute) and once done it
popped off 
*/

/*
variable environment:
where the var lives and how they relate to each other in MEMORY
each exec context has it's own var enviroment
=> if u declare it as var then it's defined inside the exec cntext

*/